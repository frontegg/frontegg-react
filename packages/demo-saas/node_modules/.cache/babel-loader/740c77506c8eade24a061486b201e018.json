{"ast":null,"code":"/*jshint -W030 */\nvar tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n\nvar parseTag = require('./parse-tag'); // re-used obj for quick lookups of components\n\n\nvar empty = Object.create ? Object.create(null) : {}; // common logic for pushing a child node onto a list\n\nfunction pushTextNode(list, html, level, start, ignoreWhitespace) {\n  // calculate correct end of the content slice in case there's\n  // no tag after the text node.\n  var end = html.indexOf('<', start);\n  var content = html.slice(start, end === -1 ? undefined : end); // if a node is nothing but whitespace, collapse it as the spec states:\n  // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n\n  if (/^\\s*$/.test(content)) {\n    content = ' ';\n  } // don't add whitespace-only text nodes if they would be trailing text nodes\n  // or if they would be leading whitespace-only text nodes:\n  //  * end > -1 indicates this is not a trailing text node\n  //  * leading node is when level is -1 and list has length 0\n\n\n  if (!ignoreWhitespace && end > -1 && level + list.length >= 0 || content !== ' ') {\n    list.push({\n      type: 'text',\n      content: content\n    });\n  }\n}\n\nmodule.exports = function parse(html, options) {\n  options || (options = {});\n  options.components || (options.components = empty);\n  var result = [];\n  var current;\n  var level = -1;\n  var arr = [];\n  var byTag = {};\n  var inComponent = false;\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return;\n      } else {\n        inComponent = false;\n      }\n    }\n\n    var isOpen = tag.charAt(1) !== '/';\n    var isComment = tag.indexOf('<!--') === 0;\n    var start = index + tag.length;\n    var nextChar = html.charAt(start);\n    var parent;\n\n    if (isOpen && !isComment) {\n      level++;\n      current = parseTag(tag);\n\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component';\n        inComponent = true;\n      }\n\n      if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n        pushTextNode(current.children, html, level, start, options.ignoreWhitespace);\n      }\n\n      byTag[current.tagName] = current; // if we're at root, push new base node\n\n      if (level === 0) {\n        result.push(current);\n      }\n\n      parent = arr[level - 1];\n\n      if (parent) {\n        parent.children.push(current);\n      }\n\n      arr[level] = current;\n    }\n\n    if (isComment || !isOpen || current.voidElement) {\n      if (!isComment) {\n        level--;\n      }\n\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children;\n        pushTextNode(parent, html, level, start, options.ignoreWhitespace);\n      }\n    }\n  }); // If the \"html\" passed isn't actually html, add it as a text node.\n\n  if (!result.length && html.length) {\n    pushTextNode(result, html, 0, 0, options.ignoreWhitespace);\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/Users/eldad/frontegg/frontegg-react-libs/node_modules/html-parse-stringify2/lib/parse.js"],"names":["tagRE","parseTag","require","empty","Object","create","pushTextNode","list","html","level","start","ignoreWhitespace","end","indexOf","content","slice","undefined","test","length","push","type","module","exports","parse","options","components","result","current","arr","byTag","inComponent","replace","tag","index","name","isOpen","charAt","isComment","nextChar","parent","voidElement","children","tagName"],"mappings":"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","sourcesContent":["/*jshint -W030 */\nvar tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\nvar parseTag = require('./parse-tag');\n// re-used obj for quick lookups of components\nvar empty = Object.create ? Object.create(null) : {};\n// common logic for pushing a child node onto a list\nfunction pushTextNode(list, html, level, start, ignoreWhitespace) {\n    // calculate correct end of the content slice in case there's\n    // no tag after the text node.\n    var end = html.indexOf('<', start);\n    var content = html.slice(start, end === -1 ? undefined : end);\n    // if a node is nothing but whitespace, collapse it as the spec states:\n    // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n    if (/^\\s*$/.test(content)) {\n        content = ' ';\n    }\n    // don't add whitespace-only text nodes if they would be trailing text nodes\n    // or if they would be leading whitespace-only text nodes:\n    //  * end > -1 indicates this is not a trailing text node\n    //  * leading node is when level is -1 and list has length 0\n    if ((!ignoreWhitespace && end > -1 && level + list.length >= 0) || content !== ' ') {\n        list.push({\n            type: 'text',\n            content: content\n        });\n    }\n}\n\nmodule.exports = function parse(html, options) {\n    options || (options = {});\n    options.components || (options.components = empty);\n    var result = [];\n    var current;\n    var level = -1;\n    var arr = [];\n    var byTag = {};\n    var inComponent = false;\n\n    html.replace(tagRE, function (tag, index) {\n        if (inComponent) {\n            if (tag !== ('</' + current.name + '>')) {\n                return;\n            } else {\n                inComponent = false;\n            }\n        }\n\n        var isOpen = tag.charAt(1) !== '/';\n        var isComment = tag.indexOf('<!--') === 0;\n        var start = index + tag.length;\n        var nextChar = html.charAt(start);\n        var parent;\n\n        if (isOpen && !isComment) {\n            level++;\n\n            current = parseTag(tag);\n            if (current.type === 'tag' && options.components[current.name]) {\n                current.type = 'component';\n                inComponent = true;\n            }\n\n            if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n                pushTextNode(current.children, html, level, start, options.ignoreWhitespace);\n            }\n\n            byTag[current.tagName] = current;\n\n            // if we're at root, push new base node\n            if (level === 0) {\n                result.push(current);\n            }\n\n            parent = arr[level - 1];\n\n            if (parent) {\n                parent.children.push(current);\n            }\n\n            arr[level] = current;\n        }\n\n        if (isComment || !isOpen || current.voidElement) {\n            if (!isComment) {\n                level--;\n            }\n            if (!inComponent && nextChar !== '<' && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                parent = level === -1 ? result : arr[level].children;\n                pushTextNode(parent, html, level, start, options.ignoreWhitespace);\n            }\n        }\n    });\n\n    // If the \"html\" passed isn't actually html, add it as a text node.\n    if (!result.length && html.length) {\n        pushTextNode(result, html, 0, 0, options.ignoreWhitespace);\n    }\n\n    return result;\n};\n"]},"metadata":{},"sourceType":"script"}