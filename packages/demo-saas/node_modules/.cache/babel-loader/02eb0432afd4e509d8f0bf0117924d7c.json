{"ast":null,"code":"var CAN_USE_DOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement); // Adapted from Modernizr\n// https://github.com/Modernizr/Modernizr/blob/acb3f0d9/feature-detects/dom/passiveeventlisteners.js#L26-L37\n\nfunction testPassiveEventListeners() {\n  if (!CAN_USE_DOM) {\n    return false;\n  }\n\n  if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n    return false;\n  }\n\n  var supportsPassiveOption = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get: function () {\n        function get() {\n          supportsPassiveOption = true;\n        }\n\n        return get;\n      }()\n    });\n\n    var noop = function noop() {};\n\n    window.addEventListener('testPassiveEventSupport', noop, opts);\n    window.removeEventListener('testPassiveEventSupport', noop, opts);\n  } catch (e) {// do nothing\n  }\n\n  return supportsPassiveOption;\n}\n\nvar memoized = void 0;\n\nfunction canUsePassiveEventListeners() {\n  if (memoized === undefined) {\n    memoized = testPassiveEventListeners();\n  }\n\n  return memoized;\n}\n\nfunction normalizeEventOptions(eventOptions) {\n  if (!eventOptions) {\n    return undefined;\n  }\n\n  if (!canUsePassiveEventListeners()) {\n    // If the browser does not support the passive option, then it is expecting\n    // a boolean for the options argument to specify whether it should use\n    // capture or not. In more modern browsers, this is passed via the `capture`\n    // option, so let's just hoist that value up.\n    return !!eventOptions.capture;\n  }\n\n  return eventOptions;\n}\n/* eslint-disable no-bitwise */\n\n/**\n * Generate a unique key for any set of event options\n */\n\n\nfunction eventOptionsKey(normalizedEventOptions) {\n  if (!normalizedEventOptions) {\n    return 0;\n  } // If the browser does not support passive event listeners, the normalized\n  // event options will be a boolean.\n\n\n  if (normalizedEventOptions === true) {\n    return 100;\n  } // At this point, the browser supports passive event listeners, so we expect\n  // the event options to be an object with possible properties of capture,\n  // passive, and once.\n  //\n  // We want to consistently return the same value, regardless of the order of\n  // these properties, so let's use binary maths to assign each property to a\n  // bit, and then add those together (with an offset to account for the\n  // booleans at the beginning of this function).\n\n\n  var capture = normalizedEventOptions.capture << 0;\n  var passive = normalizedEventOptions.passive << 1;\n  var once = normalizedEventOptions.once << 2;\n  return capture + passive + once;\n}\n\nfunction ensureCanMutateNextEventHandlers(eventHandlers) {\n  if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n    // eslint-disable-next-line no-param-reassign\n    eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n  }\n}\n\nfunction TargetEventHandlers(target) {\n  this.target = target;\n  this.events = {};\n}\n\nTargetEventHandlers.prototype.getEventHandlers = function () {\n  function getEventHandlers(eventName, options) {\n    var key = String(eventName) + ' ' + String(eventOptionsKey(options));\n\n    if (!this.events[key]) {\n      this.events[key] = {\n        handlers: [],\n        handleEvent: undefined\n      };\n      this.events[key].nextHandlers = this.events[key].handlers;\n    }\n\n    return this.events[key];\n  }\n\n  return getEventHandlers;\n}();\n\nTargetEventHandlers.prototype.handleEvent = function () {\n  function handleEvent(eventName, options, event) {\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    eventHandlers.handlers = eventHandlers.nextHandlers;\n    eventHandlers.handlers.forEach(function (handler) {\n      if (handler) {\n        // We need to check for presence here because a handler function may\n        // cause later handlers to get removed. This can happen if you for\n        // instance have a waypoint that unmounts another waypoint as part of an\n        // onEnter/onLeave handler.\n        handler(event);\n      }\n    });\n  }\n\n  return handleEvent;\n}();\n\nTargetEventHandlers.prototype.add = function () {\n  function add(eventName, listener, options) {\n    var _this = this; // options has already been normalized at this point.\n\n\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    ensureCanMutateNextEventHandlers(eventHandlers);\n\n    if (eventHandlers.nextHandlers.length === 0) {\n      eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n      this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n    }\n\n    eventHandlers.nextHandlers.push(listener);\n    var isSubscribed = true;\n\n    var unsubscribe = function () {\n      function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n\n        isSubscribed = false;\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        var index = eventHandlers.nextHandlers.indexOf(listener);\n        eventHandlers.nextHandlers.splice(index, 1);\n\n        if (eventHandlers.nextHandlers.length === 0) {\n          // All event handlers have been removed, so we want to remove the event\n          // listener from the target node.\n          if (_this.target) {\n            // There can be a race condition where the target may no longer exist\n            // when this function is called, e.g. when a React component is\n            // unmounting. Guarding against this prevents the following error:\n            //\n            //   Cannot read property 'removeEventListener' of undefined\n            _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n          }\n\n          eventHandlers.handleEvent = undefined;\n        }\n      }\n\n      return unsubscribe;\n    }();\n\n    return unsubscribe;\n  }\n\n  return add;\n}();\n\nvar EVENT_HANDLERS_KEY = '__consolidated_events_handlers__'; // eslint-disable-next-line import/prefer-default-export\n\nfunction addEventListener(target, eventName, listener, options) {\n  if (!target[EVENT_HANDLERS_KEY]) {\n    // eslint-disable-next-line no-param-reassign\n    target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n  }\n\n  var normalizedEventOptions = normalizeEventOptions(options);\n  return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n}\n\nexport { addEventListener };","map":{"version":3,"sources":["/Users/eldad/frontegg/frontegg-react-libs/node_modules/consolidated-events/lib/index.esm.js"],"names":["CAN_USE_DOM","window","document","createElement","testPassiveEventListeners","addEventListener","removeEventListener","Object","defineProperty","supportsPassiveOption","opts","get","noop","e","memoized","canUsePassiveEventListeners","undefined","normalizeEventOptions","eventOptions","capture","eventOptionsKey","normalizedEventOptions","passive","once","ensureCanMutateNextEventHandlers","eventHandlers","handlers","nextHandlers","slice","TargetEventHandlers","target","events","prototype","getEventHandlers","eventName","options","key","String","handleEvent","event","forEach","handler","add","listener","_this","length","bind","push","isSubscribed","unsubscribe","index","indexOf","splice","EVENT_HANDLERS_KEY"],"mappings":"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","sourcesContent":["var CAN_USE_DOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n// Adapted from Modernizr\n// https://github.com/Modernizr/Modernizr/blob/acb3f0d9/feature-detects/dom/passiveeventlisteners.js#L26-L37\nfunction testPassiveEventListeners() {\n  if (!CAN_USE_DOM) {\n    return false;\n  }\n\n  if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n    return false;\n  }\n\n  var supportsPassiveOption = false;\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get: function () {\n        function get() {\n          supportsPassiveOption = true;\n        }\n\n        return get;\n      }()\n    });\n    var noop = function noop() {};\n    window.addEventListener('testPassiveEventSupport', noop, opts);\n    window.removeEventListener('testPassiveEventSupport', noop, opts);\n  } catch (e) {\n    // do nothing\n  }\n\n  return supportsPassiveOption;\n}\n\nvar memoized = void 0;\n\nfunction canUsePassiveEventListeners() {\n  if (memoized === undefined) {\n    memoized = testPassiveEventListeners();\n  }\n  return memoized;\n}\n\nfunction normalizeEventOptions(eventOptions) {\n  if (!eventOptions) {\n    return undefined;\n  }\n\n  if (!canUsePassiveEventListeners()) {\n    // If the browser does not support the passive option, then it is expecting\n    // a boolean for the options argument to specify whether it should use\n    // capture or not. In more modern browsers, this is passed via the `capture`\n    // option, so let's just hoist that value up.\n    return !!eventOptions.capture;\n  }\n\n  return eventOptions;\n}\n\n/* eslint-disable no-bitwise */\n\n/**\n * Generate a unique key for any set of event options\n */\nfunction eventOptionsKey(normalizedEventOptions) {\n  if (!normalizedEventOptions) {\n    return 0;\n  }\n\n  // If the browser does not support passive event listeners, the normalized\n  // event options will be a boolean.\n  if (normalizedEventOptions === true) {\n    return 100;\n  }\n\n  // At this point, the browser supports passive event listeners, so we expect\n  // the event options to be an object with possible properties of capture,\n  // passive, and once.\n  //\n  // We want to consistently return the same value, regardless of the order of\n  // these properties, so let's use binary maths to assign each property to a\n  // bit, and then add those together (with an offset to account for the\n  // booleans at the beginning of this function).\n  var capture = normalizedEventOptions.capture << 0;\n  var passive = normalizedEventOptions.passive << 1;\n  var once = normalizedEventOptions.once << 2;\n  return capture + passive + once;\n}\n\nfunction ensureCanMutateNextEventHandlers(eventHandlers) {\n  if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n    // eslint-disable-next-line no-param-reassign\n    eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n  }\n}\n\nfunction TargetEventHandlers(target) {\n  this.target = target;\n  this.events = {};\n}\n\nTargetEventHandlers.prototype.getEventHandlers = function () {\n  function getEventHandlers(eventName, options) {\n    var key = String(eventName) + ' ' + String(eventOptionsKey(options));\n\n    if (!this.events[key]) {\n      this.events[key] = {\n        handlers: [],\n        handleEvent: undefined\n      };\n      this.events[key].nextHandlers = this.events[key].handlers;\n    }\n\n    return this.events[key];\n  }\n\n  return getEventHandlers;\n}();\n\nTargetEventHandlers.prototype.handleEvent = function () {\n  function handleEvent(eventName, options, event) {\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    eventHandlers.handlers = eventHandlers.nextHandlers;\n    eventHandlers.handlers.forEach(function (handler) {\n      if (handler) {\n        // We need to check for presence here because a handler function may\n        // cause later handlers to get removed. This can happen if you for\n        // instance have a waypoint that unmounts another waypoint as part of an\n        // onEnter/onLeave handler.\n        handler(event);\n      }\n    });\n  }\n\n  return handleEvent;\n}();\n\nTargetEventHandlers.prototype.add = function () {\n  function add(eventName, listener, options) {\n    var _this = this;\n\n    // options has already been normalized at this point.\n    var eventHandlers = this.getEventHandlers(eventName, options);\n\n    ensureCanMutateNextEventHandlers(eventHandlers);\n\n    if (eventHandlers.nextHandlers.length === 0) {\n      eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n\n      this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n    }\n\n    eventHandlers.nextHandlers.push(listener);\n\n    var isSubscribed = true;\n    var unsubscribe = function () {\n      function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n\n        isSubscribed = false;\n\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        var index = eventHandlers.nextHandlers.indexOf(listener);\n        eventHandlers.nextHandlers.splice(index, 1);\n\n        if (eventHandlers.nextHandlers.length === 0) {\n          // All event handlers have been removed, so we want to remove the event\n          // listener from the target node.\n\n          if (_this.target) {\n            // There can be a race condition where the target may no longer exist\n            // when this function is called, e.g. when a React component is\n            // unmounting. Guarding against this prevents the following error:\n            //\n            //   Cannot read property 'removeEventListener' of undefined\n            _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n          }\n\n          eventHandlers.handleEvent = undefined;\n        }\n      }\n\n      return unsubscribe;\n    }();\n    return unsubscribe;\n  }\n\n  return add;\n}();\n\nvar EVENT_HANDLERS_KEY = '__consolidated_events_handlers__';\n\n// eslint-disable-next-line import/prefer-default-export\nfunction addEventListener(target, eventName, listener, options) {\n  if (!target[EVENT_HANDLERS_KEY]) {\n    // eslint-disable-next-line no-param-reassign\n    target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n  }\n  var normalizedEventOptions = normalizeEventOptions(options);\n  return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n}\n\nexport { addEventListener };\n"]},"metadata":{},"sourceType":"module"}